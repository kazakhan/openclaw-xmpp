import fs from "fs";
import path from "path";

// Global store for XMPP clients by account ID
const xmppClients = new Map<string, any>();

// Set TLS environment variable at module load time
// This must happen BEFORE @xmpp/client is imported
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

// We'll import @xmpp/client lazily when needed
let xmppClientModule: any = null;

class Contacts {
  private file: string;
  private listCache: Array<{ jid: string; name: string }>;

  constructor(dataDir: string) {
    if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
    this.file = path.join(dataDir, "xmpp-contacts.json");
    this.listCache = this.load();
  }

  private load(): Array<{ jid: string; name: string }> {
    if (!fs.existsSync(this.file)) return [];
    try {
      return JSON.parse(fs.readFileSync(this.file, "utf8"));
    } catch {
      return [];
    }
  }

  list() {
    return this.listCache;
  }

  exists(jid: string) {
    return this.listCache.some(c => c.jid === jid);
  }
}

async function startXmpp(cfg: any, contacts: any, log: any, onMessage: (from: string, body: string) => void) {
  console.log("Starting XMPP connection with TLS rejection disabled");
  console.log("NODE_TLS_REJECT_UNAUTHORIZED:", process.env.NODE_TLS_REJECT_UNAUTHORIZED);
  
  // Lazy load @xmpp/client module
  if (!xmppClientModule) {
    console.log("Loading @xmpp/client module...");
    xmppClientModule = await import("@xmpp/client");
    console.log("XMPP client module loaded");
  }
  
  const { client, xml } = xmppClientModule;
  
  const xmpp = client({
    service: cfg.service,
    domain: cfg.domain,
    username: cfg.jid.split("@")[0],
    password: cfg.password,
    resource: cfg.resource || "clawdbot",
    tls: { rejectUnauthorized: false }  // Accept self-signed certificates
  });

  xmpp.on("error", (err: any) => {
    log.error("XMPP error", err);
    console.error("XMPP error details:", err);
  });
  xmpp.on("online", async (address: any) => {
    log.info("XMPP online as", address.toString());
    console.log("XMPP connected successfully as", address.toString());
    
    // Send initial presence to appear online
    // Just send empty presence - type="available" is default and causes error
    try {
      const presence = xml("presence");
      await xmpp.send(presence);
      console.log("âœ… Presence sent - should appear online now as", address.toString());
      log.info("Presence sent");
    } catch (err) {
      console.error("âŒ Failed to send presence:", err);
      log.error("Failed to send presence", err);
    }
  });

  xmpp.on("stanza", (stanza: any) => {
    console.log("XMPP stanza received:", stanza.toString());
    
    if (stanza.is("presence")) {
      console.log("Presence from:", stanza.attrs.from, "type:", stanza.attrs.type || "available");
    }
    
    if (stanza.is("message") && stanza.getChild("body")) {
      const from = stanza.attrs.from;
      const to = stanza.attrs.to;
      const body = stanza.getChildText("body");
      
      console.log(`Received XMPP message - From: ${from}, To: ${to}, Body: ${body}`);
      
      // Strip resource from sender JID for contact check
      const fromBareJid = from.split("/")[0];
      
      if (contacts.exists(fromBareJid)) {
        console.log(`Message from contact ${fromBareJid}, forwarding to agent`);
        onMessage(fromBareJid, body);
      } else {
        console.log(`Ignoring message from non-contact: ${fromBareJid}`);
        log.debug(`Ignoring message from non-contact: ${fromBareJid}`);
      }
    }
  });

  xmpp.start().catch((err: any) => {
    log.error("XMPP start failed", err);
    console.error("XMPP start failed details:", err);
    console.error("Error stack:", err.stack);
    console.error("Error code:", err.code);
    console.error("Error message:", err.message);
    // Don't throw, just log the error
  });

  const xmppClient = {
    send: (to: string, body: string) => {
      const message = xml("message", { type: "chat", to }, xml("body", {}, body));
      return xmpp.send(message);
    }
  };
  
  return xmppClient;
}

export function register(api: any) {
  const log = api.logger ?? console;
  log.info("Registering XMPP plugin");
  console.log("XMPP plugin register called");
  console.log("API object keys:", Object.keys(api));
  
  // Store the API/molt reference globally
  let globalApi = api;

  const xmppPlugin = {
    id: "clawdbot-xmpp",
    meta: {
      id: "clawdbot-xmpp",
      label: "XMPP",
      selectionLabel: "XMPP (Jabber)",
      docsPath: "/channels/xmpp",
      blurb: "XMPP/Jabber messaging via direct chat.",
      aliases: ["jabber", "xmpp"],
    },
    capabilities: {
      chatTypes: ["direct"],
      polls: false,
      reactions: false,
      threads: false,
      media: false,
      nativeCommands: true,
    },
    configSchema: {
      type: "object",
      properties: {
        service: { type: "string" },
        domain: { type: "string" },
        jid: { type: "string" },
        password: { type: "string" },
        dataDir: { type: "string" },
        resource: { type: "string" },
      },
      required: ["service", "domain", "jid", "password", "dataDir"],
    },
    config: {
      listAccountIds: (cfg: any) => Object.keys(cfg.channels?.xmpp?.accounts ?? {}),
      resolveAccount: (cfg: any, accountId: string) => {
        const id = accountId || "default";
        const accountConfig = cfg.channels?.xmpp?.accounts?.[id];
        return {
          accountId: id,
          enabled: accountConfig?.enabled ?? true,
          config: accountConfig ?? {},
        };
      },
      defaultAccountId: () => "default",
      isConfigured: (account: any) => Boolean(account.config.jid?.trim() && account.config.password?.trim()),
      describeAccount: (account: any) => ({
        accountId: account.accountId,
        name: account.config.jid || account.accountId,
        enabled: account.enabled,
        configured: Boolean(account.config.jid?.trim() && account.config.password?.trim()),
        tokenSource: "config",
      }),
    },
    status: {
      buildAccountSnapshot: ({ account, runtime }: any) => ({
        accountId: account.accountId,
        name: account.config.jid || account.accountId,
        enabled: account.enabled,
        configured: Boolean(account.config.jid?.trim() && account.config.password?.trim()),
        tokenSource: "config",
        running: runtime?.running ?? false,
        lastStartAt: runtime?.lastStartAt ?? null,
        lastStopAt: runtime?.lastStopAt ?? null,
        lastError: runtime?.lastError ?? null,
      }),
    },
    outbound: {
      deliveryMode: "direct",
      sendText: async ({ to, text, accountId }: any) => {
        console.log("XMPP sendText called with:", { to, text, accountId });
        
        // Get the XMPP client from global store
        const xmpp = xmppClients.get(accountId || "default");
        console.log("XMPP client available:", !!xmpp);
        
        if (!xmpp) {
          return { ok: false, error: "XMPP client not available" };
        }
        
        // For now, skip contacts check to test sending
        // TODO: Re-enable contacts check once sending works
        // const contacts = new Contacts(account.config.dataDir);
        // if (!contacts.exists(to)) {
        //   console.log(`JID ${to} not in contacts`);
        //   return { ok: false, error: `JID ${to} not in contacts` };
        // }
        
        try {
          console.log(`Attempting to send message to ${to}: ${text}`);
          await xmpp.send(to, text);
          console.log("Message sent successfully");
          return { ok: true, channel: "clawdbot-xmpp" };
        } catch (err) {
          console.error("Error sending message:", err);
          return { ok: false, error: String(err) };
        }
      },
    },
    gateway: {
      startAccount: async (ctx: any) => {
        console.log("XMPP gateway.startAccount called with ctx:", Object.keys(ctx));
        console.log("ctx.account:", ctx.account);
        
        const account = ctx.account;
        const config = account.config;
        const log = ctx.log;
        
        console.log(`XMPP startAccount called for account ${account.accountId}`);
        console.log("Account config:", config);
        
        if (!config.jid?.trim() || !config.password?.trim()) {
          console.log("Missing jid or password");
          throw new Error("XMPP account missing jid or password");
        }
        
        log?.info(`[${account.accountId}] starting XMPP connection to ${config.service}`);
        console.log(`Starting XMPP connection to ${config.service}`);
        
        const contacts = new Contacts(config.dataDir);
        const contactList = contacts.list();
        log?.info(`[${account.accountId}] loaded ${contactList.length} contacts`);
        
        let xmppClient: any = null;
        let isRunning = true;
        
  const xmpp = await startXmpp(config, contacts, log, (from: string, body: string) => {
    if (!isRunning) return;
    
    console.log("XMPP inbound message from:", from, "Body:", body);
    
    // Based on your insight: Use ctx helpers, not random APIs
    // Check ctx for receiveText or similar methods
    
    console.log("=== Looking for inbound message methods on ctx ===");
    console.log("ctx keys:", Object.keys(ctx));
    
    // Try common inbound message method names
    const inboundMethods = [
      'receiveText',
      'receiveMessage', 
      'dispatchInbound',
      'inbound',
      'handleInbound',
      'onMessage'
    ];
    
    for (const methodName of inboundMethods) {
      if (typeof (ctx as any)[methodName] === 'function') {
        console.log(`âœ… Found ctx.${methodName}`);
        try {
          // Try calling it with XMPP message data
          if (methodName === 'receiveText' || methodName === 'receiveMessage') {
            const result = await (ctx as any)[methodName]({
              from: `clawdbot-xmpp:${from}`,
              to: `clawdbot-xmpp:${config.jid}`,
              body: body,
              channel: "clawdbot-xmpp",
              accountId: account.accountId,
              sessionKey: `clawdbot-xmpp:${from}:${account.accountId}`,
              envelope: {
                type: "direct",
                source: from,
                target: config.jid,
              },
            });
            console.log(`âœ… Message forwarded via ctx.${methodName}:`, result);
            return;
          } else {
            // Try other method signatures
            const result = await (ctx as any)[methodName](from, body, {
              channel: "xmpp",
              accountId: account.accountId,
            });
            console.log(`âœ… Message forwarded via ctx.${methodName}:`, result);
            return;
          }
        } catch (err) {
          console.error(`âŒ Error with ctx.${methodName}:`, err);
        }
      }
    }
    
    // Check if ctx has a receive property with methods
    if ((ctx as any).receive && typeof (ctx as any).receive === 'object') {
      console.log("Found ctx.receive object");
      const receiveMethods = ['text', 'message', 'inbound'];
      for (const methodName of receiveMethods) {
        if (typeof (ctx as any).receive[methodName] === 'function') {
          console.log(`âœ… Found ctx.receive.${methodName}`);
          try {
            const result = await (ctx as any).receive[methodName]({
              from: `xmpp:${from}`,
              to: `xmpp:${config.jid}`,
              body: body,
              channel: "xmpp",
              accountId: account.accountId,
            });
            console.log(`âœ… Message forwarded via ctx.receive.${methodName}:`, result);
            return;
          } catch (err) {
            console.error(`âŒ Error with ctx.receive.${methodName}:`, err);
          }
        }
      }
    }
    
    // Check ctx.runtime for inbound methods
    if (ctx.runtime && typeof ctx.runtime === 'object') {
      console.log("Checking ctx.runtime for inbound methods...");
      const runtimeMethods = Object.getOwnPropertyNames(ctx.runtime).filter(
        key => typeof (ctx.runtime as any)[key] === 'function' && 
               key.toLowerCase().includes('receive')
      );
      for (const methodName of runtimeMethods) {
        console.log(`Trying ctx.runtime.${methodName}`);
        try {
          const result = await (ctx.runtime as any)[methodName]({
            from: from,
            text: body,
            channel: "xmpp",
            accountId: account.accountId,
          });
          console.log(`âœ… Message forwarded via ctx.runtime.${methodName}:`, result);
          return;
        } catch (err) {
          console.error(`âŒ Error with ctx.runtime.${methodName}:`, err);
        }
      }
    }
    
    console.log("ðŸ”´ No inbound message method found on ctx");
    console.log("Available ctx methods:", Object.getOwnPropertyNames(ctx).filter(k => typeof (ctx as any)[k] === 'function'));
    if (ctx.runtime) {
      console.log("Available ctx.runtime methods:", Object.getOwnPropertyNames(ctx.runtime).filter(k => typeof (ctx.runtime as any)[k] === 'function'));
    }
  });
        
        xmppClient = xmpp;
        
        // Store client globally by account ID
        xmppClients.set(account.accountId, xmpp);
        
        ctx.setStatus({
          accountId: account.accountId,
          running: true,
          lastStartAt: Date.now(),
        });
        
        ctx.abortSignal.addEventListener("abort", () => {
          isRunning = false;
          log?.info(`[${account.accountId}] XMPP connection stopping`);
        });
        
        return new Promise<void>((resolve) => {
          ctx.abortSignal.addEventListener("abort", () => {
            ctx.setStatus({
              accountId: account.accountId,
              running: false,
              lastStopAt: Date.now(),
            });
            resolve();
          });
        });
      },
    },
  };

  console.log("About to register XMPP channel plugin");
  api.registerChannel({ plugin: xmppPlugin });
  log.info("XMPP channel plugin registered");
  console.log("XMPP channel plugin registered");
}